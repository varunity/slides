<?php

/**
 * @file
 * Allows users to create and organize related content in an outline.
 */

/**
 * Implements hook_help().
 */
function slides_help($path, $arg) {
  switch ($path) {
    case 'admin/help#slides':
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Slides module is used for creating structured, multi-page content, such as site resource guides, manuals, and wikis. It allows you to create content that has chapters, sections, subsections, or any similarly-tiered structure. For more information, see the online handslides entry for <a href="@slides">Slides module</a>.', array('@slides' => 'http://drupal.org/handslides/modules/slides/')) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Adding and managing slides content') . '</dt>';
      $output .= '<dd>' . t('You can assign separate permissions for <em>creating</em>, <em>editing</em>, and <em>deleting</em> slides content, as well as <em>adding content to slidess</em>, and <em>creating new slidess</em>. Users with the <em>Administer slides outlines</em> permission can add <em>any</em> type of content to a slides by selecting the appropriate slides outline while editing the content. They can also view a list of all slidess, and edit and rearrange section titles on the <a href="@admin-slides">Slides administration page</a>.', array('@admin-slides' => url('admin/content/slides'))) . '</dd>';
      $output .= '<dt>' . t('Slides navigation') . '</dt>';
      $output .= '<dd>' . t("Slides pages have a default slides-specific navigation block. This navigation block contains links that lead to the previous and next pages in the slides, and to the level above the current page in the slides's structure. This block can be enabled on the <a href='@admin-block'>Blocks administration page</a>. For slides pages to show up in the slides navigation, they must be added to a slides outline.", array('@admin-block' => url('admin/structure/block'))) . '</dd>';
      $output .= '<dt>' . t('Collaboration') . '</dt>';
      $output .= '<dd>' . t('Slideshows can be created collaboratively, as they allow users with appropriate permissions to add pages into existing slidess, and add those pages to a custom table of contents menu.') . '</dd>';
      $output .= '<dt>' . t('Printing slidess') . '</dt>';
      $output .= '<dd>' . t("Users with the <em>View printer-friendly slidess</em> permission can select the <em>printer-friendly version</em> link visible at the bottom of a slides page's content to generate a printer-friendly display of the page and all of its subsections.") . '</dd>';
      $output .= '</dl>';
      return $output;
    case 'admin/content/slides':
      return '<p>' . t('The slides module offers a means to organize a collection of related content pages, collectively known as a slides. When viewed, this content automatically displays links to adjacent slides pages, providing a simple navigation system for creating and reviewing structured content.') . '</p>';
    case 'node/%/outline':
      return '<p>' . t('The outline feature allows you to include pages in the <a href="@slides">Slides hierarchy</a>, as well as move them within the hierarchy or to <a href="@slides-admin">reorder an entire slides</a>.', array('@slides' => url('slides'), '@slides-admin' => url('admin/content/slides'))) . '</p>';
  }
}

/**
 * Implements hook_theme().
 */
function slides_theme() {
  return array(
    'slides_navigation' => array(
      'variables' => array('slides_link' => NULL),
      'template' => 'slides-navigation',
    ),
     'slides_reveal_html' => array(
      'variables' => array('title' => NULL, 'contents' => NULL, 'depth' => NULL),
      'template' => 'slides-reveal-html',
    ),
   'slides_export_html' => array(
      'variables' => array('title' => NULL, 'contents' => NULL, 'depth' => NULL),
      'template' => 'slides-export-html',
    ),
    'slides_admin_table' => array(
      'render element' => 'form',
    ),
    'slides_title_link' => array(
      'variables' => array('link' => NULL),
    ),
    'slides_all_slidess_block' => array(
      'render element' => 'slides_menus',
      'template' => 'slides-all-slidess-block',
    ),
     'slides_node_reveal_html' => array(
      'variables' => array('node' => NULL, 'children' => NULL),
      'template' => 'slides-node-reveal-html',
    ),
   'slides_node_export_html' => array(
      'variables' => array('node' => NULL, 'children' => NULL),
      'template' => 'slides-node-export-html',
    ),
	'slides_reveal_wrapper' => array(
	  'render element'  => 'element',	 
    ),
  );
}

/**
 * Implements hook_permission().
 */
function slides_permission() {
  return array(
    'administer slides outlines' => array(
      'title' => t('Administer slides outlines'),
    ),
    'create new slidess' => array(
      'title' => t('Create new slidess'),
    ),
    'add content to slidess' => array(
      'title' => t('Add content and child pages to slidess'),
    ),
    'access printer-friendly version' => array(
      'title' => t('View printer-friendly slidess'),
      'description' => t('View a slides page and all of its sub-pages as a single document for ease of printing. Can be performance heavy.'),
    ),
  );
}

/**
 * Inject links into $node as needed.
 */
function slides_node_view_link($node, $view_mode) {
  $links = array();

  if (isset($node->slides['depth'])) {
    if ($view_mode == 'full' && node_is_page($node)) {
      $child_type = variable_get('slides_child_type', 'slides');
      if ((user_access('add content to slidess') || user_access('administer slides outlines')) && node_access('create', $child_type) && $node->status == 1 && $node->slides['depth'] < MENU_MAX_DEPTH) {
        $links['slides_add_child'] = array(
          'title' => t('Add next slide'),
          'href' => 'node/add/' . str_replace('_', '-', $child_type),
          'query' => array('parent' => $node->slides['mlid']),
        );
      }
       if (user_access('access printer-friendly version')) {
        $links['slides_view'] = array(
          'title' => t('View Slideshow'),
          'href' => 'slides/reveal/html/' . $node->slides['bid'],
          'attributes' => array('title' => t('Show as a slideshow presentation using reveal.js.'))
        );
	  }
if (user_access('access printer-friendly version')) {
        $links['slides_printer'] = array(
          'title' => t('Printer friendy version'),
          'href' => 'slides/export/html/' . $node->nid,
          'attributes' => array('title' => t('Show a printer-friendly version of this slides page and its sub-pages.'))
        );
      }
    }
  }

  if (!empty($links)) {
    $node->content['links']['slides'] = array(
      '#theme' => 'links__node__slides',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }
}

/**
 * Implements hook_menu().
 */
function slides_menu() {
  $items['admin/content/slides'] = array(
    'title' => 'Slides',
    'description' => "Manage your site's slides outlines.",
    'page callback' => 'slides_admin_overview',
    'access arguments' => array('administer slides outlines'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'slides.admin.inc',
  );
  $items['admin/content/slides/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/content/slides/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slides_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 8,
    'file' => 'slides.admin.inc',
  );
  $items['admin/content/slides/%node'] = array(
    'title' => 'Re-order slides pages and change titles',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slides_admin_edit', 3),
    'access callback' => '_slides_outline_access',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK,
    'file' => 'slides.admin.inc',
  );
  $items['slides'] = array(
    'title' => 'Slides',
    'page callback' => 'slides_render',
    'access arguments' => array('access content'),
    'type' => MENU_SUGGESTED_ITEM,
    'file' => 'slides.pages.inc',
  );
  $items['slides/reveal/%/%'] = array(
    'page callback' => 'slides_reveal',
    'page arguments' => array(2, 3),
    'access arguments' => array('access printer-friendly version'),
    'type' => MENU_CALLBACK,
    'file' => 'slides.pages.inc',
  );
  $items['slides/export/%/%'] = array(
    'page callback' => 'slides_export',
    'page arguments' => array(2, 3),
    'access arguments' => array('access printer-friendly version'),
    'type' => MENU_CALLBACK,
    'file' => 'slides.pages.inc',
  );
  $items['node/%node/outline'] = array(
    'title' => 'Outline',
    'page callback' => 'slides_outline',
    'page arguments' => array(1),
    'access callback' => '_slides_outline_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'slides.pages.inc',
  );
  $items['node/%node/outline/remove'] = array(
    'title' => 'Remove from outline',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('slides_remove_form', 1),
    'access callback' => '_slides_outline_remove_access',
    'access arguments' => array(1),
    'file' => 'slides.pages.inc',
  );

  return $items;
}

/**
 * Menu item access callback - determine if the outline tab is accessible.
 */
function _slides_outline_access($node) {
  return user_access('administer slides outlines') && node_access('view', $node);
}

/**
 * Menu item access callback - determine if the user can remove nodes from the outline.
 */
function _slides_outline_remove_access($node) {
  return isset($node->slides) && ($node->slides['bid'] != $node->nid) && _slides_outline_access($node);
}

/**
 * Implements hook_admin_paths().
 */
function slides_admin_paths() {
  if (variable_get('node_admin_theme')) {
    $paths = array(
      'node/*/outline' => TRUE,
      'node/*/outline/remove' => TRUE,
    );
    return $paths;
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function slides_entity_info_alter(&$info) {
  // Add the 'Slides' view mode for nodes.
  $info['node']['view modes'] += array(
    'slides' => array(
      'label' => t('Slides'),
      'custom settings' => FALSE,
    ),
  );
  // Add the 'Print' view mode for nodes.
  $info['node']['view modes'] += array(
    'print' => array(
      'label' => t('Print'),
      'custom settings' => FALSE,
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function slides_block_info() {
  $block = array();
  $block['navigation']['info'] = t('Slides navigation');
  $block['navigation']['cache'] = DRUPAL_CACHE_PER_PAGE | DRUPAL_CACHE_PER_ROLE;

  return $block;
}

/**
 * Implements hook_block_view().
 *
 * Displays the slides table of contents in a block when the current page is a
 * single-node view of a slides node.
 */
function slides_block_view($delta = '') {
  $block = array();
  $current_bid = 0;
  if ($node = menu_get_object()) {
    $current_bid = empty($node->slides['bid']) ? 0 : $node->slides['bid'];
  }

  if (variable_get('slides_block_mode', 'all pages') == 'all pages') {
    $block['subject'] = t('Slides navigation');
    $slides_menus = array();
    $pseudo_tree = array(0 => array('below' => FALSE));
    foreach (slides_get_slidess() as $slides_id => $slides) {
      if ($slides['bid'] == $current_bid) {
        // If the current page is a node associated with a slides, the menu
        // needs to be retrieved.
        $slides_menus[$slides_id] = menu_tree_output(menu_tree_all_data($node->slides['menu_name'], $node->slides));
      }
      else {
        // Since we know we will only display a link to the top node, there
        // is no reason to run an additional menu tree query for each slides.
        $slides['in_active_trail'] = FALSE;
        // Check whether user can access the slides link.
        $slides_node = node_load($slides['nid']);
        $slides['access'] = node_access('view', $slides_node);
        $pseudo_tree[0]['link'] = $slides;
        $slides_menus[$slides_id] = menu_tree_output($pseudo_tree);
      }
    }
    $slides_menus['#theme'] = 'slides_all_slidess_block';
    $block['content'] = $slides_menus;
  }
  elseif ($current_bid) {
    // Only display this block when the user is browsing a slides.
  $select = db_select('node', 'n')
    ->fields('n', array('title'))
    ->condition('n.nid', $node->slides['bid'])
    ->addTag('node_access');
    $title = $select->execute()->fetchField();
    // Only show the block if the user has view access for the top-level node.
    if ($title) {
      $tree = menu_tree_all_data($node->slides['menu_name'], $node->slides);
      // There should only be one element at the top level.
      $data = array_shift($tree);
      $block['subject'] = theme('slides_title_link', array('link' => $data['link']));
      $block['content'] = ($data['below']) ? menu_tree_output($data['below']) : '';
    }
  }

  return $block;
}

/**
 * Implements hook_block_configure().
 */
function slides_block_configure($delta = '') {
  $block = array();
  $options = array(
    'all pages' => t('Show block on all pages'),
    'slides pages' => t('Show block only on slides pages'),
  );
  $form['slides_block_mode'] = array(
    '#type' => 'radios',
    '#title' => t('Slides navigation block display'),
    '#options' => $options,
    '#default_value' => variable_get('slides_block_mode', 'all pages'),
    '#description' => t("If <em>Show block on all pages</em> is selected, the block will contain the automatically generated menus for all of the site's slidess. If <em>Show block only on slides pages</em> is selected, the block will contain only the one menu corresponding to the current page's slides. In this case, if the current page is not in a slides, no block will be displayed. The <em>Page specific visibility settings</em> or other visibility settings can be used in addition to selectively display this block."),
    );

  return $form;
}

/**
 * Implements hook_block_save().
 */
function slides_block_save($delta = '', $edit = array()) {
  $block = array();
  variable_set('slides_block_mode', $edit['slides_block_mode']);
}

/**
* Default theme for the wrapper around a user's achievements page.
*  
* @param $variables
*   An associative array containing:
*   - element: A render containing the user's achievements page.
*/
function theme_slides_reveal_wrapper($variables) {
	return '<section>' . $variables['element']['#children'] . '</section>';
}

/**
 * Returns HTML for a link to a slides title when used as a block title.
 *
 * @param $variables
 *   An associative array containing:
 *   - link: An array containing title, href and options for the link.
 *
 * @ingroup themeable
 */
function theme_slides_title_link($variables) {
  $link = $variables['link'];

  $link['options']['attributes']['class'] = array('slides-title');

  return l($link['title'], $link['href'], $link['options']);
}

/**
 * Returns an array of all slidess.
 *
 * This list may be used for generating a list of all the slidess, or for building
 * the options for a form select.
 */
function slides_get_slidess() {
  $all_slidess = &drupal_static(__FUNCTION__);

  if (!isset($all_slidess)) {
    $all_slidess = array();
    $nids = db_query("SELECT DISTINCT(bid) FROM {slides}")->fetchCol();

    if ($nids) {
      $query = db_select('slides', 'b', array('fetch' => PDO::FETCH_ASSOC));
      $query->join('node', 'n', 'b.nid = n.nid');
      $query->join('menu_links', 'ml', 'b.mlid = ml.mlid');
      $query->addField('n', 'type', 'type');
      $query->addField('n', 'title', 'title');
      $query->fields('b');
      $query->fields('ml');
      $query->condition('n.nid', $nids, 'IN');
      $query->condition('n.status', 1);
      $query->orderBy('ml.weight');
      $query->orderBy('ml.link_title');
      $query->addTag('node_access');
      $result2 = $query->execute();
      foreach ($result2 as $link) {
        $link['href'] = $link['link_path'];
        $link['options'] = unserialize($link['options']);
        $all_slidess[$link['bid']] = $link;
      }
    }
  }

  return $all_slidess;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Adds the slides fieldset to the node form.
 *
 * @see slides_pick_slides_nojs_submit()
 */
function slides_form_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];
  $access = user_access('administer slides outlines');
  if (!$access) {
    if (user_access('add content to slidess') && ((!empty($node->slides['mlid']) && !empty($node->nid)) || slides_type_is_allowed($node->type))) {
      // Already in the slides hierarchy, or this node type is allowed.
      $access = TRUE;
    }
  }

  if ($access) {
    _slides_add_form_elements($form, $form_state, $node);
    // Since the "Slides" dropdown can't trigger a form submission when
    // JavaScript is disabled, add a submit button to do that. slides.css hides
    // this button when JavaScript is enabled.
    $form['slides']['pick-slides'] = array(
      '#type' => 'submit',
      '#value' => t('Change slides (update list of parents)'),
      '#submit' => array('slides_pick_slides_nojs_submit'),
      '#weight' => 20,
    );
  }
}

/**
 * Submit handler to change a node's slides.
 *
 * This handler is run when JavaScript is disabled. It triggers the form to
 * rebuild so that the "Parent item" options are changed to reflect the newly
 * selected slides. When JavaScript is enabled, the submit button that triggers
 * this handler is hidden, and the "Slides" dropdown directly triggers the
 * slides_form_update() Ajax callback instead.
 *
 * @see slides_form_update()
 */
function slides_pick_slides_nojs_submit($form, &$form_state) {
  $form_state['node']->slides = $form_state['values']['slides'];
  $form_state['rebuild'] = TRUE;
}

/**
 * Build the parent selection form element for the node form or outline tab.
 *
 * This function is also called when generating a new set of options during the
 * Ajax callback, so an array is returned that can be used to replace an existing
 * form element.
 */
function _slides_parent_select($slides_link) {
  if (variable_get('menu_override_parent_selector', FALSE)) {
    return array();
  }
  // Offer a message or a drop-down to choose a different parent page.
  $form = array(
    '#type' => 'hidden',
    '#value' => -1,
    '#prefix' => '<div id="edit-slides-plid-wrapper">',
    '#suffix' => '</div>',
  );

  if ($slides_link['nid'] === $slides_link['bid']) {
    // This is a slides - at the top level.
    if ($slides_link['original_bid'] === $slides_link['bid']) {
      $form['#prefix'] .= '<em>' . t('This is the top-level page in this slides.') . '</em>';
    }
    else {
      $form['#prefix'] .= '<em>' . t('This will be the top-level page in this slides.') . '</em>';
    }
  }
  elseif (!$slides_link['bid']) {
    $form['#prefix'] .= '<em>' . t('No slides selected.') . '</em>';
  }
  else {
    $form = array(
      '#type' => 'select',
      '#title' => t('Parent item'),
      '#default_value' => $slides_link['plid'],
      '#description' => t('The parent page in the slides. The maximum depth for a slides and all child pages is !maxdepth. Some pages in the selected slides may not be available as parents if selecting them would exceed this limit.', array('!maxdepth' => MENU_MAX_DEPTH)),
      '#options' => slides_toc($slides_link['bid'], $slides_link['parent_depth_limit'], array($slides_link['mlid'])),
      '#attributes' => array('class' => array('slides-title-select')),
      '#prefix' => '<div id="edit-slides-plid-wrapper">',
      '#suffix' => '</div>',
    );
  }

  return $form;
}

/**
 * Build the common elements of the slides form for the node and outline forms.
 */
function _slides_add_form_elements(&$form, &$form_state, $node) {
  // If the form is being processed during the Ajax callback of our slides bid
  // dropdown, then $form_state will hold the value that was selected.
  if (isset($form_state['values']['slides'])) {
    $node->slides = $form_state['values']['slides'];
  }

  $form['slides'] = array(
    '#type' => 'fieldset',
    '#title' => t('Slides outline'),
    '#weight' => 10,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
    '#attributes' => array(
      'class' => array('slides-form'),
    ),
    '#attached' => array(
      'js' => array(drupal_get_path('module', 'slides') . '/slides.js'),
    ),
    '#tree' => TRUE,
    '#attributes' => array('class' => array('slides-outline-form')),
  );
  foreach (array('menu_name', 'mlid', 'nid', 'router_path', 'has_children', 'options', 'module', 'original_bid', 'parent_depth_limit') as $key) {
    $form['slides'][$key] = array(
      '#type' => 'value',
      '#value' => $node->slides[$key],
    );
  }

  $form['slides']['plid'] = _slides_parent_select($node->slides);

  // @see _slides_admin_table_tree(). The weight may be larger than 15.
  $form['slides']['weight'] = array(
    '#type' => 'weight',
    '#title' => t('Weight'),
    '#default_value' => $node->slides['weight'],
    '#delta' => max(15, abs($node->slides['weight'])),
    '#weight' => 5,
    '#description' => t('Pages at a given level are ordered first by weight and then by title.'),
  );
  $options = array();
  $nid = isset($node->nid) ? $node->nid : 'new';

  if (isset($node->nid) && ($nid == $node->slides['original_bid']) && ($node->slides['parent_depth_limit'] == 0)) {
    // This is the top level node in a maximum depth slides and thus cannot be moved.
    $options[$node->nid] = $node->title;
  }
  else {
    foreach (slides_get_slidess() as $slides) {
      $options[$slides['nid']] = $slides['title'];
    }
  }

  if (user_access('create new slidess') && ($nid == 'new' || ($nid != $node->slides['original_bid']))) {
    // The node can become a new slides, if it is not one already.
    $options = array($nid => '<' . t('create a new slides') . '>') + $options;
  }
  if (!$node->slides['mlid']) {
    // The node is not currently in the hierarchy.
    $options = array(0 => '<' . t('none') . '>') + $options;
  }

  // Add a drop-down to select the destination slides.
  $form['slides']['bid'] = array(
    '#type' => 'select',
    '#title' => t('Slides'),
    '#default_value' => $node->slides['bid'],
    '#options' => $options,
    '#access' => (bool) $options,
    '#description' => t('Your page will be a part of the selected slides.'),
    '#weight' => -5,
    '#attributes' => array('class' => array('slides-title-select')),
    '#ajax' => array(
      'callback' => 'slides_form_update',
      'wrapper' => 'edit-slides-plid-wrapper',
      'effect' => 'fade',
      'speed' => 'fast',
    ),
  );
}

/**
 * Renders a new parent page select element when the slides selection changes.
 *
 * This function is called via Ajax when the selected slides is changed on a node
 * or slides outline form.
 *
 * @return
 *   The rendered parent page select element.
 */
function slides_form_update($form, $form_state) {
  return $form['slides']['plid'];
}

/**
 * Common helper function to handles additions and updates to the slides outline.
 *
 * Performs all additions and updates to the slides outline through node addition,
 * node editing, node deletion, or the outline tab.
 */
function _slides_update_outline($node) {
  if (empty($node->slides['bid'])) {
    return FALSE;
  }
  $new = empty($node->slides['mlid']);

  $node->slides['link_path'] = 'node/' . $node->nid;
  $node->slides['link_title'] = $node->title;
  $node->slides['parent_mismatch'] = FALSE; // The normal case.

  if ($node->slides['bid'] == $node->nid) {
    $node->slides['plid'] = 0;
    $node->slides['menu_name'] = slides_menu_name($node->nid);
  }
  else {
    // Check in case the parent is not is this slides; the slides takes precedence.
    if (!empty($node->slides['plid'])) {
      $parent = db_query("SELECT * FROM {slides} WHERE mlid = :mlid", array(
        ':mlid' => $node->slides['plid'],
      ))->fetchAssoc();
    }
    if (empty($node->slides['plid']) || !$parent || $parent['bid'] != $node->slides['bid']) {
      $node->slides['plid'] = db_query("SELECT mlid FROM {slides} WHERE nid = :nid", array(
        ':nid' => $node->slides['bid'],
      ))->fetchField();
      $node->slides['parent_mismatch'] = TRUE; // Likely when JS is disabled.
    }
  }

  if (menu_link_save($node->slides)) {
    if ($new) {
      // Insert new.
      db_insert('slides')
        ->fields(array(
          'nid' => $node->nid,
          'mlid' => $node->slides['mlid'],
          'bid' => $node->slides['bid'],
        ))
        ->execute();
      // Reset the cache of stored slidess.
      drupal_static_reset('slides_get_slidess');
    }
    else {
      if ($node->slides['bid'] != db_query("SELECT bid FROM {slides} WHERE nid = :nid", array(
          ':nid' => $node->nid,
        ))->fetchField()) {
        // Update the bid for this page and all children.
        slides_update_bid($node->slides);
        // Reset the cache of stored slidess.
        drupal_static_reset('slides_get_slidess');
      }
    }

    return TRUE;
  }

  // Failed to save the menu link.
  return FALSE;
}

/**
 * Update the bid for a page and its children when it is moved to a new slides.
 *
 * @param $slides_link
 *   A fully loaded menu link that is part of the slides hierarchy.
 */
function slides_update_bid($slides_link) {
  $query = db_select('menu_links');
  $query->addField('menu_links', 'mlid');
  for ($i = 1; $i <= MENU_MAX_DEPTH && $slides_link["p$i"]; $i++) {
    $query->condition("p$i", $slides_link["p$i"]);
  }
  $mlids = $query->execute()->fetchCol();

  if ($mlids) {
    db_update('slides')
      ->fields(array('bid' => $slides_link['bid']))
      ->condition('mlid', $mlids, 'IN')
      ->execute();
  }
}

/**
 * Get the slides menu tree for a page, and return it as a linear array.
 *
 * @param $slides_link
 *   A fully loaded menu link that is part of the slides hierarchy.
 * @return
 *   A linear array of menu links in the order that the links are shown in the
 *   menu, so the previous and next pages are the elements before and after the
 *   element corresponding to $node. The children of $node (if any) will come
 *   immediately after it in the array, and links will only be fetched as deep
 *   as one level deeper than $slides_link.
 */
function slides_get_flat_menu($slides_link) {
  $flat = &drupal_static(__FUNCTION__, array());

  if (!isset($flat[$slides_link['mlid']])) {
    // Call menu_tree_all_data() to take advantage of the menu system's caching.
    $tree = menu_tree_all_data($slides_link['menu_name'], $slides_link, $slides_link['depth'] + 1);
    $flat[$slides_link['mlid']] = array();
    _slides_flatten_menu($tree, $flat[$slides_link['mlid']]);
  }

  return $flat[$slides_link['mlid']];
}

/**
 * Recursive helper function for slides_get_flat_menu().
 */
function _slides_flatten_menu($tree, &$flat) {
  foreach ($tree as $data) {
    if (!$data['link']['hidden']) {
      $flat[$data['link']['mlid']] = $data['link'];
      if ($data['below']) {
        _slides_flatten_menu($data['below'], $flat);
      }
    }
  }
}

/**
 * Fetches the menu link for the previous page of the slides.
 */
function slides_prev($slides_link) {
  // If the parent is zero, we are at the start of a slides.
  if ($slides_link['plid'] == 0) {
    return NULL;
  }
  $flat = slides_get_flat_menu($slides_link);
  // Assigning the array to $flat resets the array pointer for use with each().
  $curr = NULL;
  do {
    $prev = $curr;
    list($key, $curr) = each($flat);
  } while ($key && $key != $slides_link['mlid']);

  if ($key == $slides_link['mlid']) {
    // The previous page in the slides may be a child of the previous visible link.
    if ($prev['depth'] == $slides_link['depth'] && $prev['has_children']) {
      // The subtree will have only one link at the top level - get its data.
      $tree = slides_menu_subtree_data($prev);
      $data = array_shift($tree);
      // The link of interest is the last child - iterate to find the deepest one.
      while ($data['below']) {
        $data = end($data['below']);
      }

      return $data['link'];
    }
    else {
      return $prev;
    }
  }
}

/**
 * Fetches the menu link for the next page of the slides.
 */
function slides_next($slides_link) {
  $flat = slides_get_flat_menu($slides_link);
  // Assigning the array to $flat resets the array pointer for use with each().
  do {
    list($key, $curr) = each($flat);
  }
  while ($key && $key != $slides_link['mlid']);

  if ($key == $slides_link['mlid']) {
    return current($flat);
  }
}

/**
 * Format the menu links for the child pages of the current page.
 */
function slides_children($slides_link) {
  $flat = slides_get_flat_menu($slides_link);

  $children = array();

  if ($slides_link['has_children']) {
    // Walk through the array until we find the current page.
    do {
      $link = array_shift($flat);
    }
    while ($link && ($link['mlid'] != $slides_link['mlid']));
    // Continue though the array and collect the links whose parent is this page.
    while (($link = array_shift($flat)) && $link['plid'] == $slides_link['mlid']) {
      $data['link'] = $link;
      $data['below'] = '';
      $children[] = $data;
    }
  }

  if ($children) {
    $elements = menu_tree_output($children);
    return drupal_render($elements);
  }
  return '';
}

/**
 * Generate the corresponding menu name from a slides ID.
 */
function slides_menu_name($bid) {
  return 'slides-toc-' . $bid;
}

/**
 * Implements hook_node_load().
 */
function slides_node_load($nodes, $types) {
  $result = db_query("SELECT * FROM {slides} b INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE b.nid IN (:nids)", array(':nids' =>  array_keys($nodes)), array('fetch' => PDO::FETCH_ASSOC));
  foreach ($result as $record) {
    $nodes[$record['nid']]->slides = $record;
    $nodes[$record['nid']]->slides['href'] = $record['link_path'];
    $nodes[$record['nid']]->slides['title'] = $record['link_title'];
    $nodes[$record['nid']]->slides['options'] = unserialize($record['options']);
  }
}

/**
 * Implements hook_node_view().
 */
function slides_node_view($node, $view_mode) {
  if ($view_mode == 'full') {
    if (!empty($node->slides['bid']) && empty($node->in_preview)) {
      $node->content['slides_navigation'] = array(
        '#markup' => theme('slides_navigation', array('slides_link' => $node->slides)),
        '#weight' => 100,
      );
    }
  }

  if ($view_mode != 'rss') {
    slides_node_view_link($node, $view_mode);
  }
}

/**
 * Implements hook_page_alter().
 *
 * Add the slides menu to the list of menus used to build the active trail when
 * viewing a slides page.
 */
function slides_page_alter(&$page) {
  if (($node = menu_get_object()) && !empty($node->slides['bid'])) {
    $active_menus = menu_get_active_menu_names();
    $active_menus[] = $node->slides['menu_name'];
    menu_set_active_menu_names($active_menus);
  }
}

/**
 * Implements hook_node_presave().
 */
function slides_node_presave($node) {
  // Always save a revision for non-administrators.
  if (!empty($node->slides['bid']) && !user_access('administer nodes')) {
    $node->revision = 1;
    // The database schema requires a log message for every revision.
    if (!isset($node->log)) {
      $node->log = '';
    }
  }
  // Make sure a new node gets a new menu link.
  if (empty($node->nid)) {
    $node->slides['mlid'] = NULL;
  }
}

/**
 * Implements hook_node_insert().
 */
function slides_node_insert($node) {
  if (!empty($node->slides['bid'])) {
    if ($node->slides['bid'] == 'new') {
      // New nodes that are their own slides.
      $node->slides['bid'] = $node->nid;
    }
    $node->slides['nid'] = $node->nid;
    $node->slides['menu_name'] = slides_menu_name($node->slides['bid']);
    _slides_update_outline($node);
  }
}

/**
 * Implements hook_node_update().
 */
function slides_node_update($node) {
  if (!empty($node->slides['bid'])) {
    if ($node->slides['bid'] == 'new') {
      // New nodes that are their own slides.
      $node->slides['bid'] = $node->nid;
    }
    $node->slides['nid'] = $node->nid;
    $node->slides['menu_name'] = slides_menu_name($node->slides['bid']);
    _slides_update_outline($node);
  }
}

/**
 * Implements hook_node_delete().
 */
function slides_node_delete($node) {
  if (!empty($node->slides['bid'])) {
    if ($node->nid == $node->slides['bid']) {
      // Handle deletion of a top-level post.
      $result = db_query("SELECT b.nid FROM {menu_links} ml INNER JOIN {slides} b on b.mlid = ml.mlid WHERE ml.plid = :plid", array(
        ':plid' => $node->slides['mlid']
      ));
      foreach ($result as $child) {
        $child_node = node_load($child->nid);
        $child_node->slides['bid'] = $child_node->nid;
        _slides_update_outline($child_node);
      }
    }
    menu_link_delete($node->slides['mlid']);
    db_delete('slides')
      ->condition('mlid', $node->slides['mlid'])
      ->execute();
    drupal_static_reset('slides_get_slidess');
  }
}

/**
 * Implements hook_node_prepare().
 */
function slides_node_prepare($node) {
  // Prepare defaults for the add/edit form.
  if (empty($node->slides) && (user_access('add content to slidess') || user_access('administer slides outlines'))) {
    $node->slides = array();

    if (empty($node->nid) && isset($_GET['parent']) && is_numeric($_GET['parent'])) {
      // Handle "Add child page" links:
      $parent = slides_link_load($_GET['parent']);

      if ($parent && $parent['access']) {
        $node->slides['bid'] = $parent['bid'];
        $node->slides['plid'] = $parent['mlid'];
        $node->slides['menu_name'] = $parent['menu_name'];
      }
    }
    // Set defaults.
    $node->slides += _slides_link_defaults(!empty($node->nid) ? $node->nid : 'new');
  }
  else {
    if (isset($node->slides['bid']) && !isset($node->slides['original_bid'])) {
      $node->slides['original_bid'] = $node->slides['bid'];
    }
  }
  // Find the depth limit for the parent select.
  if (isset($node->slides['bid']) && !isset($node->slides['parent_depth_limit'])) {
    $node->slides['parent_depth_limit'] = _slides_parent_depth_limit($node->slides);
  }
}

/**
 * Find the depth limit for items in the parent select.
 */
function _slides_parent_depth_limit($slides_link) {
  return MENU_MAX_DEPTH - 1 - (($slides_link['mlid'] && $slides_link['has_children']) ? menu_link_children_relative_depth($slides_link) : 0);
}

/**
 * Form altering function for the confirm form for a single node deletion.
 */
function slides_form_node_delete_confirm_alter(&$form, $form_state) {
  $node = node_load($form['nid']['#value']);

  if (isset($node->slides) && $node->slides['has_children']) {
    $form['slides_warning'] = array(
      '#markup' => '<p>' . t('%title is part of a slides outline, and has associated child pages. If you proceed with deletion, the child pages will be relocated automatically.', array('%title' => $node->title)) . '</p>',
      '#weight' => -10,
    );
  }
}

/**
 * Return an array with default values for a slides link.
 */
function _slides_link_defaults($nid) {
  return array('original_bid' => 0, 'menu_name' => '', 'nid' => $nid, 'bid' => 0, 'router_path' => 'node/%', 'plid' => 0, 'mlid' => 0, 'has_children' => 0, 'weight' => 0, 'module' => 'slides', 'options' => array());
}

/**
 * Process variables for slides-all-slidess-block.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $slides_menus
 *
 * All non-renderable elements are removed so that the template has full
 * access to the structured data but can also simply iterate over all
 * elements and render them (as in the default template).
 *
 * @see slides-navigation.tpl.php
 */
function template_preprocess_slides_all_slidess_block(&$variables) {
  // Remove all non-renderable elements.
  $elements = $variables['slides_menus'];
  $variables['slides_menus'] = array();
  foreach (element_children($elements) as $index) {
    $variables['slides_menus'][$index] = $elements[$index];
  }
}

/**
 * Process variables for slides-navigation.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $slides_link
 *
 * @see slides-navigation.tpl.php
 */
function template_preprocess_slides_navigation(&$variables) {
  $slides_link = $variables['slides_link'];

  // Provide extra variables for themers. Not needed by default.
  $variables['slides_id'] = $slides_link['bid'];
  $variables['slides_title'] = check_plain($slides_link['link_title']);
  $variables['slides_url'] = 'node/' . $slides_link['bid'];
  $variables['current_depth'] = $slides_link['depth'];
  $variables['tree'] = '';

  if ($slides_link['mlid']) {
    $variables['tree'] = slides_children($slides_link);

    if ($prev = slides_prev($slides_link)) {
      $prev_href = url($prev['href']);
      drupal_add_html_head_link(array('rel' => 'prev', 'href' => $prev_href));
      $variables['prev_url'] = $prev_href;
      $variables['prev_title'] = check_plain($prev['title']);
    }

    if ($slides_link['plid'] && $parent = slides_link_load($slides_link['plid'])) {
      $parent_href = url($parent['href']);
      drupal_add_html_head_link(array('rel' => 'up', 'href' => $parent_href));
      $variables['parent_url'] = $parent_href;
      $variables['parent_title'] = check_plain($parent['title']);
    }

    if ($next = slides_next($slides_link)) {
      $next_href = url($next['href']);
      drupal_add_html_head_link(array('rel' => 'next', 'href' => $next_href));
      $variables['next_url'] = $next_href;
      $variables['next_title'] = check_plain($next['title']);
    }
  }

  $variables['has_links'] = FALSE;
  // Link variables to filter for values and set state of the flag variable.
  $links = array('prev_url', 'prev_title', 'parent_url', 'parent_title', 'next_url', 'next_title');
  foreach ($links as $link) {
    if (isset($variables[$link])) {
      // Flag when there is a value.
      $variables['has_links'] = TRUE;
    }
    else {
      // Set empty to prevent notices.
      $variables[$link] = '';
    }
  }
}

/**
 * Recursively processes and formats menu items for slides_toc().
 *
 * This helper function recursively modifies the $toc array for each item in
 * $tree, ignoring items in the exclude array or at a depth greater than the
 * limit.  Truncates titles over thirty characters and appends an indentation
 * string incremented by depth.
 *
 * @param $tree
 *   The data structure of the slides's menu tree.  Includes hidden links.
 * @param $indent
 *   A string appended to each menu item title. Increments by '--' per depth
 *   level.
 * @param $toc
 *   Reference to the table of contents array. This is modified in place, so the
 *   function does not have a return value.
 * @param $exclude
 *   Optional array of mlid values. Any link whose mlid is in this array will be
 *   excluded (along with its children).
 * @param $depth_limit
 *   Any link deeper than this value will be excluded (along with its children).
 */
function _slides_toc_recurse($tree, $indent, &$toc, $exclude, $depth_limit) {
  foreach ($tree as $data) {
    if ($data['link']['depth'] > $depth_limit) {
      // Don't iterate through any links on this level.
      break;
    }

    if (!in_array($data['link']['mlid'], $exclude)) {
      $toc[$data['link']['mlid']] = $indent . ' ' . truncate_utf8($data['link']['title'], 30, TRUE, TRUE);
      if ($data['below']) {
        _slides_toc_recurse($data['below'], $indent . '--', $toc, $exclude, $depth_limit);
      }
    }
  }
}

/**
 * Returns an array of slides pages in table of contents order.
 *
 * @param $bid
 *   The ID of the slides whose pages are to be listed.
 * @param $depth_limit
 *   Any link deeper than this value will be excluded (along with its children).
 * @param $exclude
 *   Optional array of mlid values. Any link whose mlid is in this array
 *   will be excluded (along with its children).
 * @return
 *   An array of mlid, title pairs for use as options for selecting a slides page.
 */
function slides_toc($bid, $depth_limit, $exclude = array()) {
  $tree = menu_tree_all_data(slides_menu_name($bid));
  $toc = array();
  _slides_toc_recurse($tree, '', $toc, $exclude, $depth_limit);

  return $toc;
}

/**
 * Process variables for slides-reveal-html.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $title
 * - $contents
 * - $depth
 *
 * @see slides-reveal-html.tpl.php
 */
function template_preprocess_slides_reveal_html(&$variables) {
  global $base_url, $language;

  $variables['title'] = check_plain($variables['title']);
  $variables['base_url'] = $base_url;
  $variables['language'] = $language;
  $variables['language_rtl'] = ($language->direction == LANGUAGE_RTL);
  $variables['head'] = drupal_get_html_head();
}

/**
 * Traverse the slides tree to build printable or revealable output.
 *
 * During the traversal, the $visit_func() callback is applied to each
 * node, and is called recursively for each child of the node (in weight,
 * title order).
 *
 * @param $tree
 *   A subtree of the slides menu hierarchy, rooted at the current page.
 * @param $visit_func
 *   A function callback to be called upon visiting a node in the tree.
 * @return
 *   The output generated in visiting each node.
 */
function slides_reveal_traverse($tree, $visit_func) {
  $output = '';

  foreach ($tree as $data) {
    // Note- access checking is already performed when building the tree.
    if ($node = node_load($data['link']['nid'], FALSE)) {
      $children = '';

      if ($data['below']) {
        $children = slides_reveal_traverse($data['below'], $visit_func);
      }

      if (function_exists($visit_func)) {
        $output .= call_user_func($visit_func, $node, $children);
      }
      else {
        // Use the default function.
        $output .= slides_node_reveal($node, $children);
      }
    }
  }

  return $output;
}

/**
 * Generates printer-friendly HTML for a node.
 *
 * @see slides_reveal_traverse()
 *
 * @param $node
 *   The node that will be output.
 * @param $children
 *   All the rendered child nodes within the current node.
 * @return
 *   The HTML generated for the given node.
 */
function slides_node_reveal($node, $children = '') {
  $build = node_view($node, 'slides');
  unset($build['#theme']);
  $build['slides'] = array(
        '#theme_wrappers' => array('slides_reveal_wrapper'),
	    );
  
  // @todo Rendering should happen in the template using render().
  $node->rendered = drupal_render($build);
  return theme('slides_node_reveal_html', array('node' => $node, 'children' => $children));
}

/**
 * Process variables for slides-node-reveal-html.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $node
 * - $children
 *
 * @see slides-node-reveal-html.tpl.php
 */
function template_preprocess_slides_node_reveal_html(&$variables) {
  $variables['depth'] = $variables['node']->slides['depth'];
  $variables['title'] = check_plain($variables['node']->title);
  $variables['content'] = $variables['node']->rendered;
}

/**
 * Process variables for slides-export-html.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $title
 * - $contents
 * - $depth
 *
 * @see slides-export-html.tpl.php
 */
function template_preprocess_slides_export_html(&$variables) {
  global $base_url, $language;

  $variables['title'] = check_plain($variables['title']);
  $variables['base_url'] = $base_url;
  $variables['language'] = $language;
  $variables['language_rtl'] = ($language->direction == LANGUAGE_RTL);
  $variables['head'] = drupal_get_html_head();
}

/**
 * Traverse the slides tree to build printable or exportable output.
 *
 * During the traversal, the $visit_func() callback is applied to each
 * node, and is called recursively for each child of the node (in weight,
 * title order).
 *
 * @param $tree
 *   A subtree of the slides menu hierarchy, rooted at the current page.
 * @param $visit_func
 *   A function callback to be called upon visiting a node in the tree.
 * @return
 *   The output generated in visiting each node.
 */
function slides_export_traverse($tree, $visit_func) {
  $output = '';

  foreach ($tree as $data) {
    // Note- access checking is already performed when building the tree.
    if ($node = node_load($data['link']['nid'], FALSE)) {
      $children = '';

      if ($data['below']) {
        $children = slides_export_traverse($data['below'], $visit_func);
      }

      if (function_exists($visit_func)) {
        $output .= call_user_func($visit_func, $node, $children);
      }
      else {
        // Use the default function.
        $output .= slides_node_export($node, $children);
      }
    }
  }

  return $output;
}

/**
 * Generates printer-friendly HTML for a node.
 *
 * @see slides_export_traverse()
 *
 * @param $node
 *   The node that will be output.
 * @param $children
 *   All the rendered child nodes within the current node.
 * @return
 *   The HTML generated for the given node.
 */
function slides_node_export($node, $children = '') {
  $build = node_view($node, 'print');
  unset($build['#theme']);
  // @todo Rendering should happen in the template using render().
  $node->rendered = drupal_render($build);

  return theme('slides_node_export_html', array('node' => $node, 'children' => $children));
}

/**
 * Process variables for slides-node-export-html.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $node
 * - $children
 *
 * @see slides-node-export-html.tpl.php
 */
function template_preprocess_slides_node_export_html(&$variables) {
  $variables['depth'] = $variables['node']->slides['depth'];
  $variables['title'] = check_plain($variables['node']->title);
  $variables['content'] = $variables['node']->rendered;
}

/**
 * Determine if a given node type is in the list of types allowed for slidess.
 */
function slides_type_is_allowed($type) {
  return in_array($type, variable_get('slides_allowed_types', array('slides')));
}

/**
 * Implements hook_node_type_update().
 *
 * Update slides module's persistent variables if the machine-readable name of a
 * node type is changed.
 */
function slides_node_type_update($type) {
  if (!empty($type->old_type) && $type->old_type != $type->type) {
    // Update the list of node types that are allowed to be added to slidess.
    $allowed_types = variable_get('slides_allowed_types', array('slides'));
    $key = array_search($type->old_type, $allowed_types);

    if ($key !== FALSE) {
      $allowed_types[$type->type] = $allowed_types[$key] ? $type->type : 0;
      unset($allowed_types[$key]);
      variable_set('slides_allowed_types', $allowed_types);
    }

    // Update the setting for the "Add child page" link.
    if (variable_get('slides_child_type', 'slides') == $type->old_type) {
      variable_set('slides_child_type', $type->type);
    }
  }
}

/**
 * Like menu_link_load(), but adds additional data from the {slides} table.
 *
 * Do not call when loading a node, since this function may call node_load().
 */
function slides_link_load($mlid) {
  if ($item = db_query("SELECT * FROM {menu_links} ml INNER JOIN {slides} b ON b.mlid = ml.mlid LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = :mlid", array(
      ':mlid' => $mlid,
    ))->fetchAssoc()) {
    _menu_link_translate($item);
    return $item;
  }

  return FALSE;
}

/**
 * Get the data representing a subtree of the slides hierarchy.
 *
 * The root of the subtree will be the link passed as a parameter, so the
 * returned tree will contain this item and all its descendents in the menu tree.
 *
 * @param $link
 *   A fully loaded menu link.
 * @return
 *   An subtree of menu links in an array, in the order they should be rendered.
 */
function slides_menu_subtree_data($link) {
  $tree = &drupal_static(__FUNCTION__, array());

  // Generate a cache ID (cid) specific for this $menu_name and $link.
  $cid = 'links:' . $link['menu_name'] . ':subtree-cid:' . $link['mlid'];

  if (!isset($tree[$cid])) {
    $cache = cache_get($cid, 'cache_menu');

    if ($cache && isset($cache->data)) {
      // If the cache entry exists, it will just be the cid for the actual data.
      // This avoids duplication of large amounts of data.
      $cache = cache_get($cache->data, 'cache_menu');

      if ($cache && isset($cache->data)) {
        $data = $cache->data;
      }
    }

    // If the subtree data was not in the cache, $data will be NULL.
    if (!isset($data)) {
      $query = db_select('menu_links', 'ml', array('fetch' => PDO::FETCH_ASSOC));
      $query->join('menu_router', 'm', 'm.path = ml.router_path');
      $query->join('slides', 'b', 'ml.mlid = b.mlid');
      $query->fields('b');
      $query->fields('m', array('load_functions', 'to_arg_functions', 'access_callback', 'access_arguments', 'page_callback', 'page_arguments', 'delivery_callback', 'title', 'title_callback', 'title_arguments', 'type'));
      $query->fields('ml');
      $query->condition('menu_name', $link['menu_name']);
      for ($i = 1; $i <= MENU_MAX_DEPTH && $link["p$i"]; ++$i) {
        $query->condition("p$i", $link["p$i"]);
      }
      for ($i = 1; $i <= MENU_MAX_DEPTH; ++$i) {
        $query->orderBy("p$i");
      }
      $links = array();
      foreach ($query->execute() as $item) {
        $links[] = $item;
      }
      $data['tree'] = menu_tree_data($links, array(), $link['depth']);
      $data['node_links'] = array();
      menu_tree_collect_node_links($data['tree'], $data['node_links']);
      // Compute the real cid for slides subtree data.
      $tree_cid = 'links:' . $item['menu_name'] . ':subtree-data:' . hash('sha256', serialize($data));
      // Cache the data, if it is not already in the cache.

      if (!cache_get($tree_cid, 'cache_menu')) {
        cache_set($tree_cid, $data, 'cache_menu');
      }
      // Cache the cid of the (shared) data using the menu and item-specific cid.
      cache_set($cid, $tree_cid, 'cache_menu');
    }
    // Check access for the current user to each item in the tree.
    menu_tree_check_access($data['tree'], $data['node_links']);
    $tree[$cid] = $data['tree'];
  }

  return $tree[$cid];
}
